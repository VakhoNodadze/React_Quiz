1. რა არის Virtual Dom და ახსენით როგორ მუშAობს ის? რამდენი Virtual Domს ინარჩუნებს რეაქტი ერთდორულად?
Virtual Dom არის Real Dom-ის blueprint, ანუ რეალურად Real Dom-ის ანალოგია (შეიცავს იგივე ინფორმაციას, დოკუმენტის შესახებ), თუმცა ვინაიდან შეგვიძლია წარმოვიდგინოთ, როგორც blueprint მასზე ოპერაციები ნაკლებად expensive არის ვიდრე Real Dom-ზე. React ერთდროულად ინახავს ორ Virtual Dom-ს, საიდანაც ერთი ინახავს ინფორმაციას კომპონენტის render ფუნქციის გამოძახებამდე დოკუმენტის შესახებ ინფორმაციას, ხოლო მეორე უახლეს ინფორმაციას დოკუმენტის შესახებ, შემდეგ რეაქტი ამ ორ Snapshot-ს ადარებს ერთმანეთს, პოულობს განსხვავებებს და ამ განსხვავებების შესაბამისი ცვლილებები შეაქვს Real Dom-ში. 

2. რა არის JSX? 
JSX(JavaScript XML) რეალურად არის სინტაქსური sugar რეაქტში და საბოლოოდ React.createElement() ფუნქციის გამოძახებად გარდაიქმნება. ვინაიდან, რეაქტის კომპონენტებიდან ხშირად Nested React Element-ებს ვაბრუნებთ, JSX გვაძლევს საშუალებას HTML-ის მსგავსი კოდი ვწეროთ კომპონენტის return-ში და თავიდან ავიცილოთ React.CreateElement() ფუნქციების საკმაოდ რთულად წასაკითხი Nesting. თუმცა, რაც არ უნდა დავაბრუნოთ  JSX-ით, ზუსტად იგივე შედეგის მიღწევა შეიძლება React.createElement() ფუნქციით.

3. რას ნიშნავს One way data-binding და რას ნიშნავს Two way data-binding? რომელი აქვს რეაქტს?
ზოგადა One way data-binding და Two way data-binding განსაზღვრავს კომპონენტებს შორის  მონაცემთა მიმოცვლას (Data flow). One way data-binding ნიშნავს რომ data-ს გადაცემა ხდება ერთი მიმართულებით მშობელი კომპონენტიდან შვილ კომპონენტში, ანუ შვილ კომპონენტს პირდაპირ შეცვლა არ შეუძლია მშობელ კომპონენტში არსებული state-ს, ხოლო Two way data-binding-ის შემთხევაში (Two way data-binding-ს იყენებს ანგულარი) data-ს გადაცემა ხდება ორი მიმართულებით, როგორც მშობლიდან შვილი კომპონენტისკენ, ასევე შვილიდან მშობელი კომპონენტის მიმართულებით. React Angular-სგან განსხვავებით იყენებს One way data-binding-ს.

4. რა არის props და state?
props არის მშობელი კომპონენტის მიერ შვილი კომპონენტისთვის გადაცემული data. აღნიშნული data არის immutable (პირდაპირ მისი ცვლილება შეუძლებელია), შვილი კომპონენტი ღებულობს Object-ს რომელსაც ჩვენ შეგვიძლია ნებისმიერი სახელი დავარქვათ, თუმცა კონვენციის თანახმად props-ს ვარქმევთ. State არის დროის მიმდინარე მომენტში კომპონენტის მონაცემების შესახებ ინფორმაცია, props-სგან განსხვავებით state-ს ცვლილება შესაძლებელია. ფუნქციურ კომპონენტებში ამისათვის Hook-ებიდან დაბრუნებული სთეითის დასააბდეითებელი ფუნქცია გამოიყენება. მაგალითად: const [name, useName] = useState(''), აქ name არის უშუალოდ state, ხოლო useName გვაძლევს საშუალებას ეს სთეითი შევცვალოთ. სთეითის ცვლილება იწვევს კომპონენტის re-execution-ს. (ხელახლა გამოძახებას).

5. რა არის key? რისთვის გამოიყენება ის?
რეაქტში key-ს ვიყენებთ მაშინ, როდესაც ხდება List-ის რენდერი. Key საჭიროა იმისათვის, რომ რეაქტი მიხვდეს ლისთის რომელი აითემები აქვს უკვე დარენდერებული და re-render-ის შემთხვეევაში სწორად დაარენდერეოს დააბდეითებული ლისთი. ლისთის(ერეის) რენდერის დროს  Key-ს არ გამოყენების შემთხვევაში რეაქტი იძლევა warrning-ს და იმ შემთხვევაში თუ შემდგომში მოხდება ამ ლისთის ცვლილება და re-render, აუცილებლად მივიღებთ ჩვენთვის მოულოდნელ შედეგს.

6. მე-6ში სწორი არის ბ და გ პასუხი. 
<button onClick={handleClick}>Click Me</button>
და 
<button onClick={()=>handleClick()}>Click Me</button>
აქ პირველი ა პასუხი იმიტომ არ არის სწორი, რომ onClick-ს უნდა გადაეცეს ფუნქციის რეფერენსი და როდესაც დათრიგერდება Click ივენთი რეაქტი გამოიძახებს რეფერენსად გადაცემულ ფუნქციას, ხოლო თუ რეფერენსის მაგივრად უშუალოდ პირდაპირ ფუნქციას გამოვიძახებთ, მაშინ event handler-ის რეგისტრაციის დროს მოხდება ამ ფუნქციის პირდაპირ გამოძახება, რაც მოგვცემს ჩვენთვის არასასურველ შედეგს.

7. აქ სწორი პასუხი არის ა. Arr.map((item) => <span key={item.id}>{item}</span>, რადგან სხვა პასუხებში არ გვაქვს key, გარდა ამისა ბ და დ პასუხი საერთოდ არ იმუშავებს, რადგან ბ-ში თუ ვიყენებთ {} ფრჩხილებშ arrow ფუნქციის ტანად, მაშინ საჭიროა გვქონდეს return statement, ხოლო დ-ში ფუნქციის ტანი გვიწერია () ასეთ ფრჩხილებში რაც ასევე არასწორია. გ-პასუხი იმუშავებს (არ დაერორდება) მაგრამ მოგვცემს ვარნინგს, რახან არ არის key გამოყენებული ლისთის (ერეის) რენდერის დროს.

8. კოდი დაბეჭდავს {
	name: 'Vakhtang', 
	address: {
		city: 'Batumi',
		street: 'Gorgiladze Str'
	}
}
ეს იქნება newPerson ობჯექთი.
ხოლო ძველი Person ობჯექთი იქნება შემდეგნაირი:
{
	name: 'Giorgi',
	address: {
		city: 'Batumi',
		street: 'Gorgiladze Str'
	}
}

აღნიშნულ შედეგს იმიგომ მივიღებთ, რომ spread ოპერატორი დასფრედავს person objcet-ს newPerson-ობჯექთში, შესაბამისად person და newPerson Heap-ში სხვადასხვა მისამართს უყურებდნენ იქნება, თუმცა ვინაიდან ნესთედ ობჯექთი იყო person, ამიტომაც person.address და newPerson.address ერთდაიგივე მისამართს უყურებდნენ იქნება Heap-ში. რამაც გამოიწვია ის, რომ ორივე ობჯექთის address.city და address.street newPerson-ის ცვლილების შემდეგ ორივეგან შეიცვალა.


